数据结构分物理结构和逻辑结构：
    1.物理结构面向计算机硬件，有顺序存储结构、链式存储结构；
    2.逻辑结构面向实际问题，有线性结构、集合结构、树形结构、图形结构。

算法的设计要求：时间效率高、存储量低。

推导大O阶：
    1.用常数1取代运行时间中所有加法常数；
    2.在修改后的运行次数函数中，只保留最高阶项；
    3.去除与最高阶项想乘的常数。

常见的时间复杂度（一般指最坏时间复杂度）：
    O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N) < O(N!) < O(N^N)

AVL树、红黑树、B树、B+树：
    1.AVL树和红黑树适合内部存储应用，B树适合外部存储应用
    2.AVL树和红黑树都是用旋转保持平衡，AVL树对每个插入操作最多需要两次次旋转（单/双旋），对每个删除操作最多需要O（logn）次旋转
    3.红黑树对每个插入和删除操作，任何不平衡都会在三次旋转之内解决
    4.查找、插入、删除的时间均为log(n)，红黑树的算法时间复杂度和AVL相同，但红黑树的统计性能要好于平衡二叉树，但极端性能略差
    5.B和B+树的区别在于，B+树非叶结点只包含导航信息，不包含实际值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。
    6.B树和B+树详细介绍：http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html

散列表定义：存储位置 = f(关键字)
适用场景：查找性能要求高，记录之间关系无要求的数据
设计一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。
散列函数构造方法：
    1.f(key) = a * key + b  适合表小且连续
    2.数字抽取分析法（如手机号后4位）、平方取中法、折叠法
    3.f(key) = key % p (p <= m)  m为表长
    4.f(key) = random(key)  适合关键字长度不等
    5.fi(key) = (f(key) + di) % m (di为随机数列)
数据结构：数组、链地址法

排序算法：
    1.归并排序最稳定
    2.排序数越少，简单排序越合适，反之用改进排序方法
    3.优化后的快速排序是性能最好的排序算法（如：三数取中选取枢轴、去掉不必要的交换、小数组用插入排序、尾递归优化）

======================================================

关键路径算法思路（对AOE网拓扑排序，然后计算时间）：
    1.创建邻接链表数组，并统计每个顶点的入度并写入邻接数组中，以及创建最早时间数组（初始化0）、最晚时间数组；
    2.创建A栈和B栈，把源点（入度为0的点）放入A栈中，开始遍历栈中顶点；
    3.从A中弹出顶部元素，放入B栈；
    4.遍历被弹出顶点的出边顶点，使其入度减一，若被减顶点入度变为0，则放入A栈中；
    5.在遍历过程中，计算出边顶点的最早时间小于被弹出顶点的最早时间及出边权值和，则此和赋值给出边顶点；
    6.重复3-5步骤，直到A栈为空，若弹出元素的个数小于所有顶点个数，则该AOE网有回路，算法停止；
    7.初始化最晚时间数组为数组中最大值（汇点为最大），并开始遍历B栈；
    8.弹出B栈顶部元素，并遍历该元素的出边顶点；
    9.若被弹出元素的最晚时间大于了出边顶点的最晚时间及边权值之差，则此差值赋予被弹出元素；
    10.重复8-9步骤，直到B栈为空，此时最早时间数组中与最晚时间数组中时间值相等的顶点为关键路径顶点；
    11.若展示关键路径，则遍历最早时间数组，并遍历每个顶点的出边，依次判断当前顶点和对应所有出边顶点；
    12.若当前顶点和对应某个出边点在两个时间数组中都相等，则之间的路径为关键路径。

二叉排序树删除思路：
    1.指定删除值，通过二叉排序树搜索（左子节点<父节点<右子节点），返回其父节点指针和目标节点指针；
    2.若目标节点找不到，则删除失败；
    3.若目标节点为根元素，且根元素只有左子节点或右子节点，则根元素指针指向其子节点，并删除之前根元素；
    4.若目标节点为非根元素，则必有父节点。若目标元素只有左或右子节点，先其左或右子节点对接其父节点，再删除目标节点；
    5.若目标元素都有左右子节点，则再找出目标元素的前继节点（无右子节点）及前继父节点；
    6.若前继节点不是目标节点的左子节点，先对接前继节点的左子节点和其父节点（右子节点对接），然后前继节点的值再覆盖目标节点的值，删除前继节点；
    7.若前继节点是目标节点的左子节点，则前继节点的值覆盖目标节点值，目标节点的左子节点对接前继节点的左子节点。

