《啊哈！算法》已学算法知识列表：

排序：桶排序、冒泡排序、堆排序、快速排序

遍历：深度优先遍历、广度优先遍历

图的单源最短路径：Floyd算法、Dijkstra算法、Bellman-Ford算法、Bellman队列优化

树：二叉树特性、最小（大）堆建立、并查集

图的最小生成树：Kruskal算法、Prim算法

=============================================================

堆排序（从小到大）：
    1.建立一维数组，并从数组中间开始向前遍历（二叉树性质：最后一个非叶节点恰好在所有节点中间）；
    2.先判断当前节点有无左子节点，有则比较谁更小，再判断有无右子节点，有则比较谁更小；
    3.若最小的不是当前节点，而是左右子节点中的一个，则置换两点的值，让三点中最上点为最小值；
    4.被置换的点再按照2-3步骤向下置换；
    5.重复2-4步骤直到遍历完毕，形成了最小堆，此时堆顶是最小的；
    6.把最小的放入新数组中，再把堆底最后数覆盖堆顶数，执行2-4步骤；
    7.反复执行6步直到覆盖完毕，形成从小到大排序好的新数组。

Dijkstra算法思路：
    1.选择一个源点并创建一个存储该源点到其它节点距离的dis数组、book标记数组；
    2.遍历dis数组，找出未标记节点中最小值节点，并标记该点；
    3.遍历该点的出边，并计算出边节点距源点的距离是否大于该点距源点距离及该点到出边节点之和；
    4.若大于，则更新源点到出边节点的距离为前者两距离之和；
    5.重复2-4步骤N-1次（N为节点数）。

Bellman-Ford队列优化算法思路：
    1.选择一个源点放入队列中并创建一个存储该源点到其它节点距离的dis数组（初始值为无穷大）、book标记数组；
    2.遍历队首节点的出边，若出边节点距源点距离大于队首节点距源点距离及与出边节点之和，则更新出边节点在dis数组中的值；
    3.更新后，并把对应出边节点放入队列中（若该出边节点已标记则不放入），遍历结束后队首节点弹出并取消标记；
    4.若队列中没有节点，表明源点距各点路径最短，算法结束。

Kruskal算法思路：
    1.先按路程对邻接表进行从小到大排序，并创建并查集数组；
    2.把邻接表中距离最小的对应节点放入并查集中，先判断两节点是否属于同一个祖先节点；
    3.属于则不能放入，不属于则在并查集中合并两点；
    4.反复2-3步骤，直到N-1次（N点图的最小生成树有N-1条边）。

Prim算法思路：
    1.随机选择一个源点，为生成树的根节点，并创建树到其余节点的dis距离数组、非树节点的book标记数组；
    2.选择dis数组中非树节点离树最小距离的节点，加入树种，并标记之；
    3.遍历该节点的出边节点，判断出边节点离树的距离（dis数组）是否大于该节点（已成树中一员）到出边节点的距离；
    4.若大于，则更新dis数组中对应的出边节点的距离；
    5.重复2-4步骤，直到所有节点加入树中，即N-1次（N为图的点数）。


《算法图解》已学算法知识列表：

二分查找法、选择排序、
